--- fs/namespace.c
+++ fs/namespace.c
@@ -2302,6 +2302,36 @@
 	if (data_page)
 		((char *)data_page)[PAGE_SIZE - 1] = 0;
 
+#ifdef CONFIG_RESTRICT_ROOTFS_SLAVE
+	/* Check if this is an attempt to mark "/" as recursive-slave. */
+	if (strcmp(dir_name, "/") == 0 && flags == (MS_SLAVE | MS_REC)) {
+		static const char storage[] = "/storage";
+		static const char source[]  = "/mnt/shell/emulated";
+		long res;
+
+		/* Mark /storage as recursive-slave instead. */
+		if ((res = do_mount(NULL, (char *)storage, NULL, (MS_SLAVE | MS_REC), NULL)) == 0) {
+			/* Unfortunately bind mounts from outside /storage may retain the
+			 * recursive-shared property (bug?).  This means any additional
+			 * namespace-specific bind mounts (e.g., /storage/emulated/0/Android/obb)
+			 * will also appear, shared in all namespaces, at their respective source
+			 * paths (e.g., /mnt/shell/emulated/0/Android/obb), possibly leading to
+			 * hundreds of /proc/mounts-visible bind mounts.  As a workaround, mark
+			 * /mnt/shell/emulated also as recursive-slave so that subsequent bind
+			 * mounts are confined to their namespaces. */
+			if ((res = do_mount(NULL, (char *)source, NULL, (MS_SLAVE | MS_REC), NULL)) == 0)
+				/* Both paths successfully marked as slave, leave the rest of the
+				 * filesystem hierarchy alone. */
+				return 0;
+			else
+				pr_warn("Failed to mount %s as MS_SLAVE: %ld\n", source, res);
+		} else {
+			pr_warn("Failed to mount %s as MS_SLAVE: %ld\n", storage, res);
+		}
+		/* Fallback: Mark rootfs as recursive-slave as requested. */
+	}
+#endif
+
 	/* ... and get the mountpoint */
 	retval = kern_path(dir_name, LOOKUP_FOLLOW, &path);
 	if (retval)
